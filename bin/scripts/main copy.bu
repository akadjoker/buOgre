
import math;
 
 include "keys.bu";
 include "constants.bu";

class Player
{
    var node;
    var entity;
    var animations;
    var currentState;
    var currentBase;
    var currentTop;

    // Animações indexadas
    var idleBase;
    var idleTop;
    var runBase;
    var runTop;
    var sliceVertical;
    var sliceHorizontal;

    // Propriedades de movimento
    var moveSpeed;
    var rotationSpeed;
    var isAttacking;
    var attackCooldown;
    var attackTimer;

    // Espadas
    var swordLeft;
    var swordRight;
    var trailLeft;
    var trailRight;
    var swordNodeLeft;
    var swordNodeRight;

    def init(scene,root)
    {
        self.node = root.createChild();
        self.entity = scene.createEntity("Sinbad.mesh");
        self.entity.castShadows = true;
        self.node.attachObject(self.entity);
        self.node.setPosition(0, 5, -30);
        self.node.setScale(1, 1, 1);

        // Configurar animações
        self.idleBase = self.entity.getAnimationState("IdleBase");
        self.idleTop = self.entity.getAnimationState("IdleTop");
        self.runBase = self.entity.getAnimationState("RunBase");
        self.runTop = self.entity.getAnimationState("RunTop");
        self.sliceVertical = self.entity.getAnimationState("SliceVertical");
        self.sliceHorizontal = self.entity.getAnimationState("SliceHorizontal");

        // Configurar loops
        self.idleBase.loop = true;
        self.idleTop.loop = true;
        self.runBase.loop = true;
        self.runTop.loop = true;
        self.sliceVertical.loop = false;
        self.sliceHorizontal.loop = false;

        // Estado inicial: idle
        self.currentState = "idle";
        self.idleBase.enabled = true;
        self.idleTop.enabled = true;

        // Propriedades de gameplay
        self.moveSpeed = 50.0;
        self.rotationSpeed = 5.0;
        self.isAttacking = false;
        self.attackCooldown = 0.8;  // 800ms entre ataques
        self.attackTimer = 0.0;

        // Criar espadas
        self.swordLeft = scene.createEntity("Sword.mesh");
        self.swordRight = scene.createEntity("Sword.mesh");

        // Attach espadas aos bones das mãos
        self.entity.attachObjectToBone("Handle.L", self.swordLeft);
        self.entity.attachObjectToBone("Handle.R", self.swordRight);

        // Criar nodes para os trails (na ponta das espadas)
        self.swordNodeLeft = root.createChild();
        self.swordNodeRight = root.createChild();
 
    }

    def setState(newState)
    {
        if (self.currentState == newState)
        {
            return;
        }

        // Desabilitar todas as animações
        self.idleBase.enabled = false;
        self.idleTop.enabled = false;
        self.runBase.enabled = false;
        self.runTop.enabled = false;
        self.sliceVertical.enabled = false;
        self.sliceHorizontal.enabled = false;

        // Ativar animações do novo estado
        if (newState == "idle")
        {
            self.idleBase.enabled = true;
            self.idleTop.enabled = true;
 
      
        }
        elif (newState == "running")
        {
            self.runBase.enabled = true;
            self.runTop.enabled = true;
       
            
        }
        elif (newState == "attacking")
        {
            self.sliceVertical.enabled = true;
            self.sliceVertical.setTimePosition(0);  // Reinicia a animação
            self.isAttacking = true;
         
        }

        self.currentState = newState;
    }

    def handleInput(deltaTime)
    {
        // Não processar movimento se estiver atacando
        if (self.isAttacking)
        {
            return;
        }

        var moveForward = 0.0;
        var turnDirection = 0.0;

        // UP/DOWN = mover para frente/trás
        if (isKeyDown(KEY_UP))
        {
            moveForward = 1.0;
        }
        if (isKeyDown(KEY_DOWN))
        {
            moveForward = -1.0;
        }

        // LEFT/RIGHT = rodar
        if (isKeyDown(KEY_LEFT))
        {
            turnDirection = 1.0;
        }
        if (isKeyDown(KEY_RIGHT))
        {
            turnDirection = -1.0;
        }

        // Rotacionar o player
        if (turnDirection != 0.0)
        {
            var currentYaw = self.node.getYaw();
            var newYaw = currentYaw + turnDirection * self.rotationSpeed * deltaTime;
            self.node.setYaw(newYaw);
        }

        // Mover o player
        if (moveForward != 0.0)
        {
            self.setState("running");

            // Mover na direção que o player está a olhar
            var currentYaw = self.node.getYaw();
            var moveX = sin(currentYaw) * moveForward;
            var moveZ = cos(currentYaw) * moveForward;

            var pos = self.node.getPosition();
            var newX = pos.x + moveX * self.moveSpeed * deltaTime;
            var newZ = pos.z + moveZ * self.moveSpeed * deltaTime;
            self.node.setPosition(newX, pos.y, newZ);
        }
        else
        {
            self.setState("idle");
        }

        // Ataque
        if (isKeyDown(KEY_P) && self.attackTimer <= 0.0)
        {
            self.setState("attacking");
            self.attackTimer = self.attackCooldown;
        }
    }

    def update(deltaTime)
    {
        // Atualizar timer de ataque
        if (self.attackTimer > 0.0)
        {
            self.attackTimer = self.attackTimer - deltaTime;
        }

        // Processar input
        self.handleInput(deltaTime);

        // Atualizar posição dos nodes dos trails (aproximação simples)
        var pos = self.node.getPosition();
        var yaw = self.node.getYaw();

        // Offset para as mãos (esquerda e direita)
        var leftX = pos.x + cos(yaw) * 1.0 - sin(yaw) * 0.5;
        var leftZ = pos.z + sin(yaw) * 1.0 + cos(yaw) * 0.5;
        var rightX = pos.x + cos(yaw) * 1.0 + sin(yaw) * 0.5;
        var rightZ = pos.z + sin(yaw) * 1.0 - cos(yaw) * 0.5;

        self.swordNodeLeft.setPosition(leftX, pos.y + 1.5, leftZ);
        self.swordNodeRight.setPosition(rightX, pos.y + 1.5, rightZ);

        // Atualizar animações ativas
        if (self.idleBase.enabled)
        {
            self.idleBase.addTime(deltaTime);
        }
        if (self.idleTop.enabled)
        {
            self.idleTop.addTime(deltaTime);
        }
        if (self.runBase.enabled)
        {
            self.runBase.addTime(deltaTime);
        }
        if (self.runTop.enabled)
        {
            self.runTop.addTime(deltaTime);
        }
        if (self.sliceVertical.enabled)
        {
            self.sliceVertical.addTime(deltaTime);

            // Verificar se animação de ataque terminou
            if (self.sliceVertical.hasEnded())
            {
                self.isAttacking = false;
                self.setState("idle");
            }
        }
    }

}


def load_resources()
{



 
addResourceLocation("./media/Main", "FileSystem", "OgreInternal");

addResourceLocation("./media/RTShaderLib", "FileSystem", "OgreInternal");
addResourceLocation("./media/Terrain", "FileSystem", "OgreInternal");
addResourceLocation("./media/packs/SdkTrays.zip", "Zip", "Essential");
addResourceLocation("./media/packs/profiler.zip", "Zip", "Essential");


addResourceLocation("./assets/PBR", "FileSystem","General");
addResourceLocation("./assets/PBR/filament", "FileSystem","General");
addResourceLocation("./assets/materials/programs/GLSL", "FileSystem","General");
addResourceLocation("./assets/materials/programs/GLSL120", "FileSystem","General");
addResourceLocation("./assets/materials/programs/GLSL150", "FileSystem","General");
addResourceLocation("./assets/materials/programs/GLSL400", "FileSystem","General");
addResourceLocation("./assets/materials/programs/GLSLES", "FileSystem","General");
addResourceLocation("./assets/materials/programs/SPIRV", "FileSystem","General");
addResourceLocation("./assets/materials/scripts", "FileSystem","General");
addResourceLocation("./assets/materials/textures", "FileSystem","General");
addResourceLocation("./assets/materials/textures/terrain", "FileSystem","General");
addResourceLocation("./assets/models", "FileSystem","General");
addResourceLocation("./assets/particle", "FileSystem","General");
addResourceLocation("./assets/DeferredShadingMedia", "FileSystem","General");
addResourceLocation("./assets/DeferredShadingMedia/DeferredShading/post", "FileSystem","General");
addResourceLocation("./assets/PCZAppMedia", "FileSystem","General");
addResourceLocation("./assets/materials/scripts/SSAO", "FileSystem","General");
addResourceLocation("./assets/materials/textures/SSAO", "FileSystem","General");
addResourceLocation("./assets/volumeTerrain", "FileSystem","General");
addResourceLocation("./assets/CSMShadows", "FileSystem","General");
addResourceLocation("./assets/packs/Sinbad.zip", "Zip", "General");
addResourceLocation("./assets/packs/skybox.zip", "Zip", "General");
addResourceLocation("./assets/packs/skybox.zip", "Zip", "General");
addResourceLocation("./assets/packs/cubemaps.zip", "Zip", "General");
addResourceLocation("./assets/packs/cubemapsJS.zip", "Zip", "General");
 
// createResourceGroup("Assets");
// addResourceLocation("./assets/models", "FileSystem", "Assets");
// addResourceLocation("./assets/models", "FileSystem", "Assets");
// addResourceLocation("./assets/packs/Sinbad.zip", "Zip", "Assets");
// addResourceLocation("./assets/packs/skybox.zip", "Zip", "Assets");

   
initialiseAllResourceGroups();
}

CreateEngine(1024, 720, "FPS Controller", 1, false, true);

CreatePlane("ground", 1500, 1500, 20, 20, true, 1, 10.0, 10.0);

load_resources();

    
var scene = CreateScene();
var rootNode = scene.getRoot();
var camera = rootNode.createChild();

var particles=[];

def create_scne()
{

// ========== CONFIGURAÇÃO INICIAL ==========
scene.setAmbientLight(0.2, 0.2, 0.2);

// LUZ DIRECIONAL (importante para shadows)
var sun = scene.createLight("Sun", 1);  // 1 = directional
sun.setDiffuse(1.0, 0.95, 0.9);
sun.setSpecular(1.0, 1.0, 1.0);

var sunNode = rootNode.createChild();
sunNode.attachObject(sun);
sunNode.setDirection(0.3, -0.75, 0.5,TS_LOCAL,0,0,-1);  // Aponta para baixo
   
    // // Get the root SceneNode from the scene

    // // Create a directional light
    // var pointLight = scene.createLight("Sun", 1);  // 1 = directional
    // pointLight.setDiffuse(1.0, 0.95, 0.9);
    // pointLight.setSpecular(1.0, 1.0, 1.0);

    // var lightNode = rootNode.createChild();
    // lightNode.attachObject(pointLight);
    // lightNode.setDirection(0.3, -0.75, 0.5);  // Direção da luz (aponta para baixo)

   // var sunLight = scene.createLight("SunLight", 0);  // 1 = directional
    //sunLight.setDiffuse(1.0, 0.95, 0.9);
    //sunLight.setSpecular(1.0, 1.0, 1.0);
    

    
    
var cam = scene.createCamera("MainCam");
    
cam.setNearClip(0.01);
camera.attachObject(cam);
camera.setPosition(0, 50, 200);
camera.lookAt(0, 0, 0,TS_LOCAL);
 

 

var ground = scene.createEntity("ground");
ground.setCastShadows(false);  // Chão não faz sombra

var groundNode = rootNode.createChild();
groundNode.attachObject(ground);
groundNode.setPosition(0, 0, 0);
 
 

var ogreHead = scene.createEntity("ogrehead.mesh");
ogreHead.castShadows = true;  // Cabeça FAZ sombra
var headNode = rootNode.createChild();
headNode.attachObject(ogreHead);
headNode.setPosition(0, 5, 0);
headNode.setScale(0.1, 0.1, 0.1);


var viewport = Viewport(cam);
// viewport.setBackgroundColor(0.1, 0.1, 0.1);
// viewport.addCompositor("B&W", -1);
// viewport.setCompositorEnabled("B&W", true);



// viewport.addCompositor("Bloom", -1);
// viewport.setCompositorEnabled("Bloom", true);


// viewport.addCompositor("Fresnel", -1);
// viewport.setCompositorEnabled("Fresnel", true);

scene.setSkyBox(true, "Examples/CloudyNoonSkyBox", 5000.0);

    
}
 

def create_nodes()
{
    var cubeObj = scene.createCube("cubeObject",1.0,"GlowMat");
    cubeObj.convertToMesh("cubeMesh");
    
    var cube = scene.createEntity("cubeMesh");
    cube.setCastShadows(true);
    var node = rootNode.createChild();
    node.attachObject(cube);
    node.setPosition(35, 5, 0);
    node.setScale(10.1, 10.1, 10.1);
    
    var sphereOBJ  = scene.createSphere("sphereObj",2,12,12,"GlowMat");
    sphereOBJ.convertToMesh("sphereMesh");

    var sphere = scene.createEntity("sphereMesh");
    sphere.setCastShadows(true);

    node = rootNode.createChild();
    node.attachObject(sphere);
    node.setPosition(10, 1.5, 0);
    

    var cylObj = scene.createCylinder("myCylinder", 1.0, 3.0, 16, "GlowMat");
    cylObj.convertToMesh("cylinderMesh");

    var cylinder = scene.createEntity("cylinderMesh");
    cylinder.setCastShadows(true);
    node = rootNode.createChild();
    node.attachObject(cylinder);
    node.setPosition(-5, 2, 5);

    var coneObj = scene.createCone("myCone", 1.0, 3.0, 16, "GlowMat");
    coneObj.convertToMesh("coneMesh");

    var cone = scene.createEntity("coneMesh");
    cone.setCastShadows(true);
    node = rootNode.createChild();
    node.attachObject(cone);
    node.setPosition(-20, 2, 0);

    var torusObj = scene.createTorus("myTorus", 2.0, 0.5, 32, 16, "GlowMat");
    torusObj.convertToMesh("torusMesh");

    var torus = scene.createEntity("torusMesh");
    torus.setCastShadows(true);
    node = rootNode.createChild();
    node.attachObject(torus);
    node.setPosition(50, 3, 0);
}

def create_overlays()
{
    

var overlay3 = CreateOverlay("TestOverlay3");

var textRed = CreateTextArea("TextRed");
textRed.setMetricsMode(0);
textRed.setPosition(10, 5);
textRed.setDimensions(200, 30);
textRed.setCharHeight(20);
textRed.setFontName("MyFont");
textRed.setCaption("RED TEXT");
textRed.setColour(1.0, 0.0, 0.0, 1.0);
 

var panel3 = CreatePanel("Panel3");
panel3.setPosition(255, 5);
panel3.setDimensions(150, 20);
panel3.setMaterialName("BaseWhiteNoLighting");

panel3.addChild(textRed);
 

overlay3.addElement(panel3);
overlay3.show();
}

 
var currentShadowType = 0;
var shadowTypeNames = [
    "NONE",
    "STENCIL_ADDITIVE",
    "STENCIL_MODULATIVE",
    "TEXTURE_ADDITIVE",
    "TEXTURE_MODULATIVE"
];

def setupShadows(type)
{
    print("Shadow Type: " + shadowTypeNames[type]);

    scene.setShadowTechnique(type);

    if (type == 3 || type == 4)  // TEXTURE shadows
    {
        print("  - Texture Size: 2048");
        print("  - Texture Count: 3");
        print("  - Far Distance: 300.0");

        scene.setShadowTextureSize(2048);
        scene.setShadowTextureCount(3);
        scene.setShadowFarDistance(300.0);
        scene.setShadowDirLightTextureOffset(0.6);
        scene.setShadowTextureSelfShadow(true);
        scene.setShadowCasterRenderBackFaces(false);
        scene.setShadowColour(0.5, 0.5, 0.5);
    }
    elif (type == 1 || type == 2)  // STENCIL shadows
    {
        print("  - Stencil shadows (no extra config needed)");
    }
}

create_scne();
 
create_nodes();
 

CreateFPSOverlay();
create_overlays();

var player = Player(scene,rootNode);

 

// Create FPS controller
 var fpsController = FPSController(camera);
 fpsController.moveSpeed = 150.0;  // velocidade de movimento
fpsController.mouseSensitivity = 0.15;  // sensibilidade do mouse

// var tpController = ThirdPersonController(camera, player.node);
// tpController.setOffset(0, 8.0, 30);
   currentShadowType = 4;
setupShadows(currentShadowType);

//create_ribons();
 
    // Mouse tracking
    var lastMouseX = getMouseX();
    var lastMouseY = getMouseY();
    var time=0.0;

    while(EngineCanUpdate())
    {
        var deltaTime = getDeltaTime();
        var fps = getFPS();
        time = time + deltaTime;

        // Update movement flags based on keyboard input
        // fpsController.setMoveForward(isKeyDown(KEY_W));
        // fpsController.setMoveBackward(isKeyDown(KEY_S));
        // fpsController.setMoveLeft(isKeyDown(KEY_A));
        // fpsController.setMoveRight(isKeyDown(KEY_D));
        // fpsController.setMoveUp(isKeyDown(KEY_Q));
        // fpsController.setMoveDown(isKeyDown(KEY_Z));

            if (isKeyDown(KEY_1)) { currentShadowType = 0; setupShadows(currentShadowType); }
    if (isKeyDown(KEY_2)) { currentShadowType = 1; setupShadows(currentShadowType); }
    if (isKeyDown(KEY_3)) { currentShadowType = 2; setupShadows(currentShadowType); }
    if (isKeyDown(KEY_4)) { currentShadowType = 3; setupShadows(currentShadowType); }
    if (isKeyDown(KEY_5)) { currentShadowType = 4; setupShadows(currentShadowType); }

        // Calculate mouse delta
        var mouseX = getMouseX();
        var mouseY = getMouseY();
        var mouseDeltaX = 0;
        var mouseDeltaY = 0;

        if (isMouseButtonDown(MOUSE_LEFT))
        {
            mouseDeltaX = mouseX - lastMouseX;
            mouseDeltaY = mouseY - lastMouseY;
        }

        lastMouseX = mouseX;
        lastMouseY = mouseY;

        // Update controller
        fpsController.update(deltaTime, -mouseDeltaX, mouseDeltaY);
        //tpController.update(deltaTime, 0,0);

        UpdateFPSText(fps);
 
        player.update(deltaTime);

       UpdateEngine(deltaTime);
    }
    ReleaseEngine();



